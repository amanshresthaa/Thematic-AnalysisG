import logging
from typing import Dict, Any, List
import dspy
from dataclasses import dataclass
import json
import re

logger = logging.getLogger(__name__)

@dataclass
class GroupingAnalysisSignature(dspy.Signature):
    """
    A signature for grouping similar codes into sets based on 
    research objectives and a theoretical framework.
    """

    # Input Fields
    research_objectives: str = dspy.InputField(
        desc="The specific goals and research questions guiding the analysis."
    )

    theoretical_framework: Dict[str, str] = dspy.InputField(
        desc="Information about the theoretical foundation supporting the analysis."
    )

    codes: List[Dict[str, Any]] = dspy.InputField(
        desc="""
        A structured collection of developed codes, each with its definition.
        Each code entry includes:
         - code: The name or label of the developed code.
         - definition: A concise explanation of the code's meaning.
        """
    )

    # Output Fields
    groupings: List[Dict[str, Any]] = dspy.OutputField(
        desc="""
        A structured collection of code groupings. Each grouping entry includes:
         - codes: A list of code labels belonging to this grouping.
        """
    )

def group_codes(
    research_objectives: str,
    theoretical_framework: Dict[str, str],
    codes: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Uses an LLM prompt to group codes together without introducing themes or rationales.
    The LLM should return a JSON response containing 'groupings' as a list of objects,
    each having a 'codes' list of code labels.
    """

    if not codes:
        logger.warning("No codes provided for grouping.")
        return []

    # Prepare the LLM prompt
    prompt = create_prompt(research_objectives, theoretical_framework, codes)

    logger.debug("Prompt generated for grouping analysis.")

    # Interact with the LLM to generate groupings
    try:
        response = dspy.language_model.generate(
            prompt=prompt,
            max_tokens=1500,
            temperature=0.3,
            stop=["```"]
        ).strip()

        logger.debug("Response received from the language model.")

        # Parse the JSON response
        groupings = parse_response(response)

        if not groupings:
            logger.warning("No valid groupings were generated by the LLM.")
            return []

        logger.info(f"Grouping analysis completed with {len(groupings)} groups formed.")
        return groupings

    except Exception as e:
        logger.error(f"Error during grouping analysis: {e}", exc_info=True)
        return []

def create_prompt(
    research_objectives: str,
    theoretical_framework: Dict[str, str],
    codes: List[Dict[str, Any]]
) -> str:
    """
    Generates a prompt for the LLM to perform grouping analysis.
    The instructions ask for grouping without theme labels or rationales,
    only returning sets of codes that belong together.
    """

    # Format the codes for clarity
    codes_formatted = "\n".join([
        f"- **{code['code']}**: {code['definition']}"
        for code in codes
    ])

    # Extract theoretical framework components
    theory = theoretical_framework.get("theory", "N/A")
    philosophical_approach = theoretical_framework.get("philosophical_approach", "N/A")
    rationale = theoretical_framework.get("rationale", "N/A")

    # Construct the prompt
    prompt = (
        f"You are a qualitative researcher. Your task is to group the following codes into sets based on their definitions, the research objectives, and the theoretical framework.\n\n"

        f"**Research Objectives:**\n{research_objectives}\n\n"

        f"**Theoretical Framework:**\n"
        f"- Theory: {theory}\n"
        f"- Philosophical Approach: {philosophical_approach}\n"
        f"- Rationale: {rationale}\n\n"

        f"**Codes:**\n{codes_formatted}\n\n"

        f"**Instructions:**\n"
        f"- Group the codes into clusters that share similar meanings or relevance.\n"
        f"- Do not provide theme labels or rationales. Only return the grouped codes.\n"
        f"- Present the response in JSON format inside ```json``` code blocks.\n"
        f"- The JSON should have the following structure:\n\n"
        f"```json\n{{\n  \"groupings\": [\n    {{\n      \"codes\": [\"Code A\", \"Code B\"]\n    }}\n  ]\n}}\n```"
    )

    logger.debug("Prompt successfully created for the LLM.")
    return prompt

def parse_response(response: str) -> List[Dict[str, Any]]:
    """
    Extracts and parses the JSON content from the LLM's response.
    Expects a 'groupings' key, each grouping with a 'codes' list.
    """

    try:
        # Use regex to find JSON content within code blocks
        json_match = re.search(r"```json\s*(\{.*?\})\s*```", response, re.DOTALL)
        if not json_match:
            logger.error("No valid JSON found in the LLM's response.")
            logger.debug(f"Full response received: {response}")
            return []

        json_string = json_match.group(1)

        # Parse the JSON string into a Python dictionary
        response_json = json.loads(json_string)

        # Validate the structure
        if "groupings" not in response_json:
            logger.error("JSON response does not contain 'groupings' key.")
            return []

        groupings = response_json["groupings"]

        # Validate that each grouping has 'codes'
        for grouping in groupings:
            if "codes" not in grouping:
                logger.warning("A grouping does not contain 'codes' key.")
                return []

        return groupings

    except json.JSONDecodeError as e:
        logger.error(f"JSON decoding failed: {e}. Response: {response}")
        return []
    except Exception as e:
        logger.error(f"Unexpected error during response parsing: {e}")
        return []
